#!/usr/bin/python
# -*- coding: utf-8 -*-
from Foundation import (NSData,
                        NSPropertyListSerialization,
                        NSPropertyListMutableContainers,
                        NSPropertyListXMLFormat_v1_0)
import os
import plistlib
import subprocess
import sys

# set by the builder
SETUP_SCRIPT_PATH = "%SETUP_SCRIPT_PATH%"
SOFTWARE_REPO_URL = "%SOFTWARE_REPO_URL%"
API_SECRET = "%API_SECRET%"
TLS_CA_CERT = "%TLS_CA_CERT%"
DEPNOTIFY_COMMANDS = """%DEPNOTIFY_COMMANDS%"""

# the two plists
DEFAULT_PLIST = "/Library/Preferences/ManagedInstalls.plist"
ROOT_PLIST = "/var/root{}".format(DEFAULT_PLIST)
INCLUDE_DEPNOTIFY = "%INCLUDE_DEPNOTIFY%"
DEPNOTIFY_LAUNCH_AGENT_PLIST = "/Library/LaunchAgents/io.zentral.monolith.depnotify.plist"
DEPNOTIFY_CONTROL_FILE = "/var/tmp/depnotify.log"

# munki daemons
MUNKI_DAEMONS_CONFIG_FILES = [
    "/Library/LaunchDaemons/com.googlecode.munki.{}.plist".format(name)
    for name in ("managedsoftwareupdate-check",
                 "managedsoftwareupdate-install",
                 "managedsoftwareupdate-manualcheck",
                 "logouthelper")
]


# Plist utils from munki
# Credit goes to Greg Neagle
# https://github.com/munki/munki/blob/6cf7138c7c5203f376bbe2e16088b33e3608e85f/code/client/munkilib/FoundationPlist.py#L68


def read_plist(filepath):
    if not os.path.exists(filepath):
        return {}
    # Credit to Greg Neagle
    plist_data = NSData.dataWithContentsOfFile_(filepath)
    data_object, _, error = (
        NSPropertyListSerialization.
        propertyListFromData_mutabilityOption_format_errorDescription_(
            plist_data, NSPropertyListMutableContainers, None, None))
    if data_object is None:
        if error:
            error = error.encode('ascii', 'ignore')
        else:
            error = "Unknown error"
        raise Exception("%s in file %s" % (error, filepath))
    else:
        return data_object


def write_plist(data_object, filepath):
    plist_data, error = (
        NSPropertyListSerialization.
        dataFromPropertyList_format_errorDescription_(
            data_object, NSPropertyListXMLFormat_v1_0, None))
    if plist_data is None:
        if error:
            error = error.encode('ascii', 'ignore')
        else:
            error = "Unknown error"
        raise Exception(error)
    else:
        if plist_data.writeToFile_atomically_(filepath, True):
            return
        else:
            raise Exception("Failed to write plist data to %s" % filepath)


# End plist utils


def execute_setup_script():
    if SETUP_SCRIPT_PATH and os.path.exists(SETUP_SCRIPT_PATH):
        try:
            subprocess.call([SETUP_SCRIPT_PATH])
        except OSError:
            pass


def get_serial_number():
    output = subprocess.check_output(["ioreg", "-a", "-c", "IOPlatformExpertDevice", "-d", "2"])
    return plistlib.readPlistFromString(output)["IORegistryEntryChildren"][0]["IOPlatformSerialNumber"]


def update_default_plist(serial_number):
    data = read_plist(DEFAULT_PLIST)
    data.update({"ClientIdentifier": "MONOLITH_MACHINE_SERIAL_NUMBER{}".format(serial_number),
                 "SoftwareRepoURL": SOFTWARE_REPO_URL,
                 "SoftwareRepoCACertificate": TLS_CA_CERT,
                 "FollowHTTPRedirects": "all",
                 "SuppressLoginwindowInstall": True})
    # no special Manifest URL with monolith
    data.pop("ManifestURL", None)
    # force redirect via monolith for Icon and Client Resource
    data.pop("IconURL", None)
    data.pop("ClientResourceURL", None)
    write_plist(data, DEFAULT_PLIST)


def update_root_plist(serial_number):
    data = read_plist(ROOT_PLIST)
    data["AdditionalHttpHeaders"] = ["X-Zentral-Serial-Number: {}".format(serial_number),
                                     "X-Monolith-Token: {}".format(API_SECRET)]
    write_plist(data, ROOT_PLIST)


def get_console_user():
    from SystemConfiguration import SCDynamicStoreCopyConsoleUser
    cfuser = SCDynamicStoreCopyConsoleUser(None, None, None)
    return cfuser[0]


def can_launch_munki():
    # Destination volume is passed as third arg of the postinstall script
    # https://developer.apple.com/legacy/library/documentation/DeveloperTools/Conceptual/SoftwareDistribution4/Install_Operations/Install_Operations.html
    volume = sys.argv[3]
    # 1. volume is root
    if volume != "/":
        # should not happen
        return False
    # 2. no real user logged in
    return get_console_user() in (None, "loginwindow", "_mbsetupuser")


def launch_munki_daemons():
    for config_file in MUNKI_DAEMONS_CONFIG_FILES:
        subprocess.call(['/bin/launchctl', 'load', config_file])


def do_munki_run():
    subprocess.call(['/bin/launchctl', 'load',
                     '/usr/local/zentral/monolith/managedsoftwareupdate_launchd_run_once.plist'])


def include_depnotify():
    return int(INCLUDE_DEPNOTIFY) == 1


def prepare_depnotify():
    if DEPNOTIFY_COMMANDS:
        with open(DEPNOTIFY_CONTROL_FILE, "ab") as f:
            f.write(DEPNOTIFY_COMMANDS)


def cleanup_depnotify():
    if os.path.exists(DEPNOTIFY_LAUNCH_AGENT_PLIST):
        os.unlink(DEPNOTIFY_LAUNCH_AGENT_PLIST)


if __name__ == "__main__":
    execute_setup_script()
    serial_number = get_serial_number()
    update_default_plist(serial_number)
    update_root_plist(serial_number)
    if can_launch_munki():
        launch_munki_daemons()
        do_munki_run()
    if include_depnotify():
        prepare_depnotify()
    else:
        cleanup_depnotify()
